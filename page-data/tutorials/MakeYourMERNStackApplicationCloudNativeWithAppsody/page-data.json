{"componentChunkName":"component---src-templates-tutorial-template-js","path":"/tutorials/MakeYourMERNStackApplicationCloudNativeWithAppsody/","webpackCompilationHash":"ef0962491cf861be4603","result":{"data":{"markdownRemark":{"html":"<h1 id=\"make-your-mern-stack-application-cloud-native-with-appsody\"><a href=\"#make-your-mern-stack-application-cloud-native-with-appsody\" aria-label=\"make your mern stack application cloud native with appsody permalink\" class=\"header-link-icon\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Make your MERN stack application cloud-native with Appsody</h1>\n<p>This tutorial shows you how to take your existing MERN (MongoDB, ExpressJS, ReactJS, and Node.js) stack application and\nconvert it into a cloud-native application using the open source <a href=\"https://appsody.dev\">Appsody</a> project.</p>\n<p>Specifically, we show you how to use Appsody's <code>nodejs-express</code> stack to create a simple ToDo list application from the <a href=\"https://github.com/CloudNativeJS/mern-workshop\">CloudNativeJS MERN workshop</a>. By using an Appsody stack, you can delegate your chosen cloud technologies and standards to the stack which ensures consistency and reliability across your applications that use this stack.</p>\n<h2 id=\"introduction-to-appsody\"><a href=\"#introduction-to-appsody\" aria-label=\"introduction to appsody permalink\" class=\"header-link-icon\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction to Appsody</h2>\n<p><a href=\"https://appsody.dev\">Appsody</a> is an open source project that helps you create containerized applications for the cloud. Appsody applications use pre-configured application stacks that have built in cloud native capabilities, such as health checks and metrics to be used for <a href=\"https://prometheus.io/\">Prometheus</a> monitoring. The Appsody CLI allows you to run, build, and test your application locally before deploying to Kubernetes. By using Appsody you can develop cloud native applications ready to be deployed to Kubernetes without being an expert on the underlying container technology.</p>\n<h2 id=\"prerequisites\"><a href=\"#prerequisites\" aria-label=\"prerequisites permalink\" class=\"header-link-icon\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Prerequisites</h2>\n<p>To follow the step in tutorial, you need to:</p>\n<ul>\n<li><a href=\"https://appsody.dev/docs/getting-started/installation\">Install the Appsody CLI</a></li>\n<li><a href=\"https://kubernetes.io/docs/setup/\">Install Kubernetes</a></li>\n<li><a href=\"https://helm.sh/docs/intro/install/\">Install Helm</a></li>\n</ul>\n<p>You will also need to clone the MERN stack application:</p>\n<pre><code class=\"language-sh\">git clone https://github.com/CloudNativeJS/mern-workshop.git\ncd mern-workshop\n</code></pre>\n<h2 id=\"converting-your-application-to-an-appsody-application\"><a href=\"#converting-your-application-to-an-appsody-application\" aria-label=\"converting your application to an appsody application permalink\" class=\"header-link-icon\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Converting your application to an Appsody application</h2>\n<h3 id=\"mongodb-database\"><a href=\"#mongodb-database\" aria-label=\"mongodb database permalink\" class=\"header-link-icon\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MongoDB database</h3>\n<p>This application uses a MongoDB database, so you need to start a MongoDB docker container using the following commands:</p>\n<pre><code class=\"language-sh\">docker pull mongo\ndocker run -d -p 27017:27017 --name mern-mongo mongo\nexport MONGO_URL=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' mern-mongo)\n</code></pre>\n<p>This creates an instance of MongoDB listening on port <code>27017</code> and also sets the environment variable <code>MONGO_URL</code> which you will use in your backend application.</p>\n<h3 id=\"back-end-express-application\"><a href=\"#back-end-express-application\" aria-label=\"back end express application permalink\" class=\"header-link-icon\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Back-end Express application</h3>\n<p>Start by enabling Appsody for the back-end Express.js application:</p>\n<pre><code class=\"language-sh\">cd backend\nappsody init nodejs-express none\n</code></pre>\n<p>This downloads the latest Appsody nodejs-express stack and also creates a <code>.appsody-config.yaml</code> file. You can use this yaml file to configure the name of your Appsody project and stack and its version used in the project. At the time of this writing, that's nodejs-express version 0.4, but updates are posted frequently.</p>\n<p>Appsody should now be enabled for the back-end application. However you need to make a couple of adjustments to the code before the application will work with Appsody. Start by replacing the code in <code>server/routers/index.js</code> with the code shown below:</p>\n<pre><code class=\"language-js\">module.exports = function(options){\n  const express = require('express');\n  const app = express();\n\n  require('./mongo')(app, options.server);\n\n  return app;\n};\n</code></pre>\n<p>The Appsody <code>nodejs-express</code> stack includes a pre-configured Express.js app with cloud-native features, such as health checks and monitoring. You need to export your app with module.exports, so it can be consumed by this stack-provided application.</p>\n<p>Next, use the following command to remove all the duplicate files that you no longer need, as you are delegating these features to the Appsody stack:</p>\n<pre><code class=\"language-sh\">rm -rf .dockerignore chart Dockerfile scripts public sever/server.js server/routers/health.js server/routers/public.js\n</code></pre>\n<p>The following duplicate features have been removed:</p>\n<ol>\n<li>\n<p><a href=\"https://www.npmjs.com/package/appmetrics-dash\">appmetrics-dash</a> and <a href=\"https://www.npmjs.com/package/appmetrics-prometheus\">appmetrics-prometheus</a>. These application monitoring libraries are included in the nodejs-express stack by default, so we no longer need to require them in our application. appmetrics-prometheus will provide a <code>/metrics</code> endpoint for use with\nPrometheus monitoring. appmetrics-dash provides a web-based dashboard at <code>/appmetrics-dash</code> showing performance metrics of the application.</p>\n</li>\n<li>\n<p>The HTTP server for the application stack can now be accessed using options.server instead of requiring HTTP.</p>\n</li>\n<li>\n<p>log4js has been removed as the nodejs-express stack provides <a href=\"http://getpino.io/#/\">Pino</a> logging.</p>\n</li>\n<li>\n<p>Both <code>app.use</code> have been removed as they are used to catch all undefined routes and provide a 404 error. The nodejs-express stack already provides this feature.</p>\n</li>\n</ol>\n<p>Now that you made the adjustments to <code>index.js</code>, you need to update the <code>package.json</code>. Start by adding a main field that defines the entry point of the application for Appsody.</p>\n<pre><code class=\"language-json\">{\n  \"name\": \"node-backend\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Cool MERN app for Docker/Kubernetes\",\n  \"private\": true,\n  \"main\": \"server/routers/index.js\",\n  \"engines\": {\n    \"node\": \"^12.14.1\"\n  },\n  \"scripts\": {\n    \"start\": \"node server/server.js\",\n    \"build\": \"NODE_ENV=production webpack\"\n  },\n  \"dependencies\": {\n    \"appmetrics-dash\": \"^5.3.0\",\n    \"appmetrics-prometheus\": \"^3.1.0\",\n    \"body-parser\": \"^1.17.1\",\n    \"connect-mongo\": \"^3.2.0\",\n    \"cors\": \"^2.8.4\",\n    \"express\": \"^4.15.3\",\n    \"log4js\": \"^3.0.5\",\n    \"mongoose\": \"^5.8.11\"\n  }\n}\n</code></pre>\n<p>You can also remove the appmetrics-dash and appmetrics-prometheus dependencies as these are already included in the nodejs-express stack.</p>\n<pre><code class=\"language-sh\">npm uninstall appmetrics-prometheus appmetrics-dash\n</code></pre>\n<p>The application should now be fully compatible with Appsody and can be started with:</p>\n<pre><code class=\"language-sh\">appsody run  --docker-options \"-e MONGO_URL\"\n</code></pre>\n<p>The application will be running on port 3000. You passed the MONGO_URL environment variable to Appsody using the <code>--docker-options</code> option. While the application is running, any code changes you make will cause your application to restart and the changes reflected immediately to your container. You will also get access to the additional cloud-native capabilities of the Appsody nodejs-express stack:</p>\n<p>Appsody endpoints:</p>\n<ul>\n<li>Liveness endpoint: <a href=\"http://localhost:3000/live\">http://localhost:3000/live</a></li>\n<li>Readiness endpoint: <a href=\"http://localhost:3000/ready\">http://localhost:3000/ready</a></li>\n<li>Prometheus metrics endpoint: <a href=\"http://localhost:3000/metrics\">http://localhost:3000/metrics</a></li>\n<li>Metrics dashboard: <a href=\"http://localhost:3000/appmetrics-dash\">http://localhost:3000/appmetrics-dash</a> (development only)</li>\n</ul>\n<p>Application-defined endpoints:</p>\n<ul>\n<li>Health endpoint: <a href=\"http://localhost:3000/health\">http://localhost:3000/health</a></li>\n<li>API endpoint: <a href=\"http://localhost:3000/api/todos\">http://localhost:3000/api/todos</a></li>\n</ul>\n<p>The metrics dashboard is only available during development and is not included in images built using <code>appsody build</code>.</p>\n<h2 id=\"deploy-your-application-to-kubernetes\"><a href=\"#deploy-your-application-to-kubernetes\" aria-label=\"deploy your application to kubernetes permalink\" class=\"header-link-icon\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Deploy your application to Kubernetes</h2>\n<p>Now that you have converted your application to use the <code>nodejs-express</code> stack, you can use the <code>appsody deploy</code> command to deploy microservices to a <a href=\"https://kubernetes.io/\">Kubernetes</a> cluster. To follow the rest of this\ntutorial you will need the following pre-requisites installed:</p>\n<ul>\n<li>\n<p><a href=\"https://kubernetes.io/docs/setup/\">Kubernetes</a></p>\n</li>\n<li>\n<p><a href=\"https://helm.sh/docs/intro/install/\">Helm</a></p>\n</li>\n</ul>\n<h3 id=\"mongodb-database-1\"><a href=\"#mongodb-database-1\" aria-label=\"mongodb database 1 permalink\" class=\"header-link-icon\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MongoDB database</h3>\n<p>To deploy a MongoDB database to Kubernetes, we use <a href=\"https://helm.sh\">Helm</a>, a package manager for Kubernetes that allows you to install application charts into your Kubernetes cluster.</p>\n<p>Start by configuring Helm to use charts from the <em>stable</em> Helm repository.</p>\n<pre><code class=\"language-sh\">helm repo add stable https://kubernetes-charts.storage.googleapis.com\n</code></pre>\n<p>Now you can deploy MongoDB into your cluster using the stable Helm chart.</p>\n<pre><code class=\"language-sh\">helm install mongo --set replicaSet.enabled=true,service.type=LoadBalancer,replicaSet.replicas.secondary=3 stable/mongodb\n</code></pre>\n<p>Run the command <code>kubectl get all</code> and you should see the following:</p>\n<pre><code class=\"language-sh\">NAME                                    READY   STATUS    RESTARTS   AGE\npod/mongo-mongodb-arbiter-0             1/1     Running   0          21s\npod/mongo-mongodb-primary-0             0/1     Running   0          21s\npod/mongo-mongodb-secondary-0           0/1     Running   0          21s\npod/mongo-mongodb-secondary-1           0/1     Running   0          21s\npod/mongo-mongodb-secondary-2           0/1     Running   0          21s\n\n\nNAME                             TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)           AGE\nservice/kubernetes               ClusterIP      10.96.0.1       &#x3C;none>        443/TCP           7d1h\nservice/mongo-mongodb            LoadBalancer   10.102.160.21   &#x3C;pending>     27017:32574/TCP   21s\nservice/mongo-mongodb-headless   ClusterIP      None            &#x3C;none>        27017/TCP         21s\n\n\nNAME                                          DESIRED   CURRENT   READY   AGE\nreplicaset.apps/appsody-operator-7ff45fd6cc   1         1         1       3d4h\n\nNAME                                       READY   AGE\nstatefulset.apps/mongo-mongodb-arbiter     1/1     21s\nstatefulset.apps/mongo-mongodb-primary     0/1     21s\nstatefulset.apps/mongo-mongodb-secondary   0/3     21s\n</code></pre>\n<p>It may take a few minutes for all your pods to be <code>1/1 READY</code>. You can watch them become available using <code>kubectl get pods --watch</code>. Once they are all ready, you can carry on with the next steps in this tutorial.</p>\n<h3 id=\"back-end-express-application-1\"><a href=\"#back-end-express-application-1\" aria-label=\"back end express application 1 permalink\" class=\"header-link-icon\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Back-end Express application</h3>\n<p>Now we have a MongoDB database deployed to our Kubernetes cluster, we can deploy the backend application. Before we can deploy the application we need to modify the connection URL, because the deployed database uses a username and password.\nThis means we need to edit the <code>mongoConnect</code> variable in the file <code>server/routers/mongo.js</code> to the following.</p>\n<pre><code class=\"language-js\">let mongoConnect = `mongodb://${MONGO_CONFIG.mongoUser}:${MONGO_CONFIG.mongoPass}@${MONGO_CONFIG.mongoURL}:27017`;\n</code></pre>\n<p>Run the following command to build your production-ready Docker image and generate a deployment manifest file.</p>\n<pre><code class=\"language-sh\">appsody build\n</code></pre>\n<p>A new file, <code>app-deploy.yaml</code> should have been created in the back-end directory. You can use this file to deploy your application to Kubernetes. Before you can deploy the application, you need to add a few environment variables to the deployment config.</p>\n<p>To do this, simply add the password for the database to the blank value field and then add this yaml to the deployment config under the <code>spec</code> field.</p>\n<pre><code class=\"language-yaml\">env:\n  - name: MONGO_URL\n    value: mongo-mongodb\n  - name: MONGO_USER\n    value: root\n  - name: MONGO_PASS\n    value:\n</code></pre>\n<p>To get the password for the MongoDB database, run the following command:</p>\n<pre><code class=\"language-sh\">echo $(kubectl get secret --namespace default mongo-mongodb -o jsonpath=\"{.data.mongodb-root-password}\" | base64 --decode)  \n</code></pre>\n<p>The <code>spec</code> section of your <code>app-deploy.yaml</code> should now look like the following:</p>\n<pre><code class=\"language-yaml\">spec:\n  applicationImage: \"dev.local/backend\"\n  createKnativeService: false\n  env:\n  - name: MONGO_URL\n    value: mongo-mongodb\n  - name: MONGO_USER\n    value: root\n  - name: MONGO_PASS\n    value: XXXX\n  expose: true\n  livenessProbe:\n    failureThreshold: 12\n    httpGet:\n      path: /live\n      port: 3000\n    initialDelaySeconds: 5\n    periodSeconds: 2\n  monitoring:\n    labels:\n      k8s-app: backend\n  readinessProbe:\n    failureThreshold: 12\n    httpGet:\n      path: /ready\n      port: 3000\n    initialDelaySeconds: 5\n    periodSeconds: 2\n    timeoutSeconds: 1\n  service:\n    annotations:\n      prometheus.io/scrape: \"true\"\n    port: 3000\n    type: NodePort\n  stack: nodejs-express\n  version: 1.0.0\n</code></pre>\n<p>This approach is not normally recommended for environment variables that should be kept secret, such as passwords. For those environment variables, you should use <a href=\"https://kubernetes.io/docs/concepts/configuration/secret/#creating-a-secret-manually\">Kubernetes secrets</a>. For simplicity, we skipped that step.</p>\n<p>Now deploy the backend to your Kubernetes cluster using:</p>\n<pre><code class=\"language-sh\">appsody deploy --no-build\n</code></pre>\n<p>We used the <code>--no-build</code> option as we built our production-ready Docker container in the last step using <code>appsody build</code>, so there's no need to rebuild it.</p>\n<p>Once it has finished deploying, you should see a message like the following.</p>\n<pre><code class=\"language-sh\">Found deployment manifest /Users/andrewhughes/mern-blog/mern-workshop/backend/app-deploy.yaml\nUsing namespace default for deployment\nAttempting to get resource from Kubernetes ...\nRunning command: kubectl get pods \"-o=jsonpath='{.items[?(@.metadata.labels.name==\\\"appsody-operator\\\")].metadata.namespace}'\" --all-namespaces\nAttempting to get resource from Kubernetes ...\nRunning command: kubectl get deployments \"-o=jsonpath='{.items[?(@.metadata.name==\\\"appsody-operator\\\")].metadata.namespace}'\" -n default\nAttempting to get resource from Kubernetes ...\nRunning command: kubectl get pod \"-o=jsonpath='{.items[?(@.metadata.labels.name==\\\"appsody-operator\\\")].metadata.name}'\" -n default\nAttempting to get resource from Kubernetes ...\nRunning command: kubectl exec -n default -it appsody-operator-7ff45fd6cc-xzxwk -- /bin/printenv WATCH_NAMESPACE\nAttempting to apply resource in Kubernetes ...\nRunning command: kubectl apply -f /Users/andrewhughes/mern-blog/mern-workshop/backend/app-deploy.yaml --namespace default\nAppsody Deployment name is: backend\nRunning command: kubectl get rt backend -o \"jsonpath=\\\"{.status.url}\\\"\" --namespace default\nAttempting to get resource from Kubernetes ...\nRunning command: kubectl get route backend -o \"jsonpath={.status.ingress[0].host}\" --namespace default\nAttempting to get resource from Kubernetes ...\nRunning command: kubectl get svc backend -o \"jsonpath=http://{.status.loadBalancer.ingress[0].hostname}:{.spec.ports[0].nodePort}\" --namespace default\nDeployed project running at http://localhost:31811\n</code></pre>\n<p>Your Appsody <code>nodejs-express</code> application should now be successfully deployed to Kubernetes. If you want to test it before you deploy your frontend application, try a POST request to <a href=\"http://localhost:31811/api/todos\">http://localhost:31811/api/todos</a> with the following body:</p>\n<pre><code class=\"language-json\">{\n   \"task\": \"appsody task\",\n   \"author\": \"appsody\"\n}\n</code></pre>\n<p>Alternatively using cURL:</p>\n<pre><code class=\"language-sh\">curl -X POST -H 'Content-Type: application/json' -d \"{\\\"author\\\":\\\"appsody\\\",\\\"task\\\": \\\"appsody task\\\"}\" http://localhost:31811/api/todos\n</code></pre>\n<p>Now if you go to the <a href=\"http://localhost:31811/api/todos\">http://localhost:31811/api/todos</a> in your browser, you should see the task you just sent. Note that the port number used in the URLs in this tutorial may be different to the port number of your Appsody application.</p>\n<h3 id=\"front-end-react-application\"><a href=\"#front-end-react-application\" aria-label=\"front end react application permalink\" class=\"header-link-icon\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Front-end React application</h3>\n<p>To deploy the front-end application to Kubernetes, use the Helm charts that are in the charts directory. These charts are a predefined way to deploy your application to Kubernetes. In this case, the charts have already been created for this application. Normally, you would have to write your own chart to define how you want to deploy your application to Kubernetes.</p>\n<p>Before you can deploy your application, you need to make a small adjustment to the <code>API_URL</code> variable in the file <code>src/containers/App.js</code> in the <code>frontend</code> directory to use the new port of the backend application deployed to Kubernetes.</p>\n<pre><code class=\"language-js\">const API_URL = 'http://localhost:BACKEND_PORT/api/todos';\n</code></pre>\n<p>Build the Docker image for the front-end application using the following:</p>\n<pre><code class=\"language-sh\">cd frontend\ndocker build -f Dockerfile -t frontend:v1.0.0 .\n</code></pre>\n<p>Now that have you built the Docker container, deploy it to Kubernetes with Helm using the following:</p>\n<pre><code class=\"language-sh\">helm install frontend chart/frontend\n</code></pre>\n<p>You can view your deployed frontend, backend, and MongoDB in Kubernetes using:</p>\n<pre><code class=\"language-sh\">kubectl get pods\n</code></pre>\n<p>Port-forward the application to port <code>30555</code> using the following command:</p>\n<pre><code class=\"language-sh\">kubectl port-forward service/frontend-service 30555:80\n</code></pre>\n<p>The front-end application should now be accessible at <a href=\"http://localhost:30555\">http://localhost:30555</a></p>\n<p>You have now successfully taken your MERN stack application, converted it to an Appsody application, and deployed it to Kubernetes. If you want to find out more about Appsody chat to us in\n<a href=\"appsody-slack.eu-gb.mybluemix.net\">Slack</a>.</p>","frontmatter":{"title":"Make your MERN stack application cloud-native with Appsody"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"pagePath":"/tutorials/MakeYourMERNStackApplicationCloudNativeWithAppsody/"}}}